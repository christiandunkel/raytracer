
# Theoretical Tasks
[Back to main page](../README.md)

This page contains all answers to the theoretical tasks of assignment 1 to 7. Tasks without any theoretical questions are excluded from this page.

## Task 1.4

> In the following example, name types, variables and values. Explain the keyword `const` in this context. What is type conversion, and why can there be problems? Where do you see problems in the following program code?

![A block of code showing the assignment of values to different variable types.](images/task_1_4.png)

In the given code example, a bunch of values are assigned to different types of variables.

```cpp
int a = 9; // whole number type
bool b = false; // truth value type 
char c = 'a'; // character type
double d = 1.3; // floating point number
int const five = 5; // unchangeable whole number type 
double e = a/five; // equals 1.0, since integers are divided first, and only parsed to double afterwards 
five = d; // not possible, since five is a constant
```

## Task 1.5

> Explain the terms initialization and assignment in terms of variables and give an example each. What differences are there?

`Initialization` is the first assignment of a value to a variable, for example: 

```cpp
int a = 10;
```

`Assignment` is the general assignment of a value to a variable, which can but doesn't have to be the initialization. For example, both lines in the following code are assignments of values: 

```cpp
int b = 9; 
b = 10;
```

Every initialization is an assignment, but not every assignment is an initialization. The initialization only happens once, when the variable first gets a value assigned.

## Task 1.6

> Explain the term `declaration`, also sometimes referred to as `forward declaration`, and `definition`, as well as give an example each. What differences are there? Give examples for both in the context of functions, variables, and classes.

`Declaration` means in C++, that you tell the compiler, the type and size of a given variable or constant. This also applies to class structures, where you declare the type (class/struct) and functions, where you declare the function signature with the type and size of all its parameters.

```cpp
extern int a;
void foo();
int bar(int);
class FooBar;
struct BarFoo;
```

`Definition` makes in addition to the declaration of type and size, also reserves space in the memory of the machine.

```cpp
int a;
int b = 10;
int foo(int a) {return a;}
class FooBar{int a;};
struct BarFoo{int a;};
```

A declaration gives the compiler the information, that a variable or function exists, while the definition then reserves memory on the machine.

## Task 1.7

> What is part of the signature of a function? Determine the scope of all variables in the following example.

A `function signature` consists of a access modifier like *public* or *private*, possibly a *static* keyword, a return type, which may also be *void*, if nothing will be returned by the function, and a name. After that, the parameter variables are listed inside parenthesis with their type and local name each.

![Showing three functions, including a main function, a sum function to add up two doubles, and a square function that multiplies a value with itself.](images/task_1_7.png)
```cpp
int var = 3; // global scope, valid in whole class

double sum (double a, double b) {
  // a and b are only valid locally inside this function
}

int square(int var) {
  // var is only valid locally inside this function
}

int main() {
  for (int i = 0; i != 100; ++i) {
    // i is only valid inside loop
  }
}
```

## Task 1.16

> Write down a definition for each term in the list.

- `C++` is a generic, imperative, object-oriented, procedural, structured, functional programming language, that was originally intended as an extension of the C language.
- `Source code` is the sequence of high-level language instructions processed by a computer.
- `Compiler` translates program code into machine language for the processor.
- `Linker` is a number of multiple object files generated by a compiler combined into a single program. 
- `Object code` is a special intermediate product of compilers, consisting of individual modules from the source code that are translated to machine-readable code, and which can be linked by linkers.
- `Executable file` can be executed as a program by a computer.
- `main()` is the start function of a program written in the C++ language. 
- `#include` includes the content of other files into the source code, which can then be used in the source code.
- `Comments` won't be translated into machine language, and just serve as reminders, descriptions and explanations for the programmers looking at the source code. 
- `Headers`  are files with the file ending *.h* or *.hpp*, which generally declare functions and variables, that can then be defined in the linked *.cpp* file(s).
- `Programs` are series of commands to a computer for it to perform certain operations.
- `Output` is the display of the results of an executed program, generally over a terminal.
- `std::cout` is a function of the standard C++ library to output information into the terminal. 
- `std::cin` is a function of the standard C++ library to receive user input from the terminal for usage in the program.
- `<<` is the standard output operator.
- `>>` is the standard input operator.
- `Functions` are programming constructs helpful for structuring the source code, as they can be called using a function invocation. Their content can thus be executed multiple times in different contexts.
- `Functions signatures` declare a function with their access modifier, possibly a static keyword, a return type, a name and input parameters.
- `Declaration` makes a variable type and name, or function, class or struct known to the compiler.
- `Definition` reserves space in the memory of the machine for a given declaration.
- `Type` declares the kind of content of a variable or parameter.
- `Typ conversion` describes the process of converting a variable of one type into another type, for example:

```cpp
int i = 1;  
double j = i; // j equals 1.0
```

- `Variables` are a characteristic, number or quantity, that can be increased or decreased, changed or exchanged, and can be referenced by name inside the program.
- `Name` is something by which variables, functions, classes, and similar are referenced inside the source code and by which one can access its content.
- `Value` is the content of a variable, which is associated with a variable name, which can be accessed inside the program using this name.
- `Initialization` is the first assignment of a value to a variable.
- `Assignment` is the general assignment of a value to a variable, which can but doesn't have to be the initialization.
- `const` is a keyword that declares a variable as constant, making it so that its content can only be read, but not changed.
- `Scope` is the region inside the source code, where a variable is valid or *visible*, meaning it can be referenced.

## Task 2.2

> Explain the purpose of the so-called include guards in the partially given header `vec2.hpp`. What happens if you do not use include guards and try to include the `vec2.hpp` file twice? Why is that?

![A block of code showing the empty struct Vect2 with an include guard.](images/task_2_2.png)

`Include guards` are a technique with which the repeated integration of the same header is prevented. If the header, e.g. * Vec2.hpp*, would be included twice, it would result in compilation errors as the struct Vec2 would be defined twice in this case.

## Task 2.7

> Explain the difference between a `class` and a `struct`. What is a data transfer object (DTO)?

`struct` constructs have have public members by default and are useful as data structures.

`class` constructs have private members by default, and these should not be transformed to public by convention, and should only be retrieved by *get* functions!

`Data transfer objects` or *DTOs* are a design pattern in which multiple data is bundled in one object. You only have public member variables, with as little member functions as possible and with no member functions that can modify the member variables.

## Task 2.9

> What is the difference between a method and a free function in the context of `const` correctness?

According to the C ++ standard, there are no *methods*, although this term is often still used interchangeably with *functions*.  

You could use the term `method` to describe functions that are dependent on an object, meaning they're part of the instance of a class or struct. The term `function` could instead describe global, call-able constructs that aren't part of a class or struct.

Let's take a look at them in terms of `const` correctness. With constant member functions, the promise is given that the object (instance), on which the functions are called, will not be changed. For functions that are independent of objects, the `const` keyword determines, depending on the application, that a return value or parameter must not be changed.

## Task  2.12

> What does the term `Overloading`mean in C++?

*Overloading* functions describes defining different functions with the same name but different input parameters. When calling the function, the function that matches the given input parameters, is used.

## Task 3.1

> Explain the differences between sequential and associative containers. 

`Sequential containers` are container classes that store data in a sequence. The desired value is accessed either via a numerical index, which describes the location of a value in the sequence, or by wandering over all other elements until the correct index is reached. Examples in C++ are arrays, vectors, dequeues and lists.

`Associative containers` are container classes that store data using pairs of key and value, where the key describes the position at which the value is stored in the container. And the value is accessed via the key. Examples in C++ are maps and sets (where the value itself is the key).

> Choose a container for the following use cases and explain your choice
> - saving the points of a polygon
> - assignment of color names and corresponding RGB values
> - FIFO queue of print jobs

- `Saving the points of a polygon`
A *sequential container*, e.g.  an *array of 2x1 vectors*, would be the best choice here, since it does not sort by values by default, and you can use the sequential order to find out for each point what the next point to draw is.

- `assignment of color names and corresponding RGB values`
An *associative container* like a *map of 3x1 vectors* would be the best option, because one can use the key for the name of the color and the vector for the RGB values. An additional bonus is that there are no duplicate names allowed in *maps*.

- `FIFO queue of print jobs`
A good choice would be a *sequential container* like a *queue*, because with it you can process each job nicely, one after the other. One does not have to remember the order, because it is already stored in the sequence itself. And in a queue, one also doesn't have to manage ever increasing indexes, when new orders are added and old ones are removed.

### Complexity

| Name | Sequential | Associative |
| :-- | :-- | :-- |
| Insertion | Constant | O(log n) |
| Removal | Constant | O(log n) |
| Search | Constant | O(log n) |

## Task 3.3

> Explain why `std::map` is a good option when trying to determine the frequency of each number in a `std::list`?

`std::map` is useful for this task, because it only has unique keys with one value mapped to it. One can use the increment operators to increase the count for each number, and it will automatically add the number (key) to the container, if it isn't yet found within. Additional perks are, that *maps* sort keys by default and that searching within them for keys is very efficient being in logarithmic time.

## Task 3.5

> Explain why unexpected behavior can occur with the following program segment:

```cpp
std::map<string, int> matriculation_numbers;
// adding many different students
matriculation_numbers["Max Mustermann"] = 12345;
matriculation_numbers["Erika Mustermann"] = 23523;
// ...
exmatriculation (matriculation_numbers["Fred Fuchs"]);
```

>  How do you avoid this problem? 

`std::map<string, int>` should be `std::map<std::string, int>`, unless the `std` namespace was defined. 
*Maps* do not allow duplicate keys, which may be a problem as student names are used as keys in this example and duplicate names aren't uncommon. Unique IDs or the matriculation numbers themselves should have been used instead to avoid inconsistencies. 
The function `exmatriculation()` may have no access to the map variable, as it seems to be defined inside the executing function and not globally.

> What options are there for inserting and searching?

Inserting a value into the map, can be done by calling it using a key or by calling `std::make_pair()` to generate a pair consisting of key and value and adding it to the map using the `insert()` function.

```cpp
a_map[key] = value;
a_map.insert(std::make_pair(key, value));
```

Deleting a key-value-pair can by done using the  `erase()` function by calling it with a key, iterator, which would delete the element it points to, or a pair of iterators, which would remove all the elements in range of the two iterators.

```cpp
erase(key)
erase(itr)
erase(itr1,itr2) // range: itr1 to itr2-1
```

Finding a key may be done using the  `count()` function, and testing if the result is at least 1, or by calling `find(key)` and assigning the result to an iterator, then testing if the iterator equals the iterator of the end position in the map.

```cpp
if (test_map.count(key) > 0) {
  // key exists
}
    
itr = test_map.find(key);
if (itr != test_map.end()) {
  // key exists
}
```

`std::search` can be used to find the first occurrence of a character sequence in the given range according to the criterion.

`std::find` can be used to find the first occurrence of an element in the given range according to the criterion.

> Which search functions are `const`?

A normal `iterator` or a constant iterator, or `const_iterator`, may be used to iterate over a container. Normal iterators allow changing the elements that they iterate over, whilst `const` iterators do not.

## Aufgabe 4.8

**DEEP-COPY**: - copy values, objects will be traversed and their values copied as well
**SHALLOW-COPY**: - copy only simple data types, copy references to objects / complex datatypes

**copy constructor is called when**:
- an object is returned by value
- an object of class is passed to a function by value
- an object is constructed based on another object of the same class
- the compiler generates a temporary object

**by default, C++ compiler creates its own default** copy constructor (shallow-copy)

**custom copy-constructor is needed**, if there are pointers or any runtime allocation, also allows for deep copy        

**Why copy-constructor pass by value?** -> copy constructor is a function in its basic form
that is always called when there is an argument pass by value ->
if not using reference in copy constructor -> infinite loop

## Aufgabe 4.14

Move Constructor??
auto l = List<int>{1,2,3,4,5} + List<int>{6,7,8,9};

## Task 5.3

- beim Erstellen des Sphere Objekts
- ruft den Konstruktor der Basisklasse (Shape) zuerst auf, dann den Konstruktor der abgeleiteten Klasse (Sphere)
- wenn der eine Initialisierungsliste existiert, konstruktor der basisklasse wird am Anfang der Liste aufgerufen
- Konstruktor der Basisklasse kann als Punkt in Liste (am Anfang) definiert werden e.g. Shape(), Shape(string name), ..

## Task 5.5

*override*
- stellt sicher, dass eine Funktion virtuell ist
- *falls dies nicht zutrifft: compile error*
- definiert, dass eine Klasse eine virtuelle Funktion seiner Basisklasse überschreibt (ersetzt)

## Task 5.7

**dynamic variable** 
- variable whose address is determined when the program is run

**static variable**
- already known at compilation time, has memory reseved for it at compilation time

*std::shared_ptr*
- smart pointer
- retains shared ownership of an object thrugh pointer
- several smart pointers may own the same object
- object is destroyed, when:
  - last smart pointer owning it is destroyed
  - last smart pointer owning it is assigned another pointer via = o. reset()
- can own object while storing pointer to another
  - for example, can be used to point to an object's member, while still owning the object

*std::make_shared*
- construct T object and wrap it in smart pointer

`std::shared_ptr<Sphere> s1 = std::make_shared<Sphere>(position, 1.2f, red, "sphere0");`
- static pointer -> static pointer
  - in compilation-time known
  - can use all functions of sphere

`std::shared_ptr<Shape> s2 = std::make_shared<Sphere>(position, 1.2f, red, "sphere1");`
- static pointer -> to dynamic object
  - in run-time looks for Sphere object
  - can only run functions of Sphere (but virtual functions overriden by sphere still work)

## Task 5.8

*order of constructor / destructor calls*
1. constructor s1 (shape)
2. constructor s1 (sphere)
3. constructor s2 (shape)
4. constructor s2 (sphere)
5. destructor s1 (sphere)
6. destructor s1 (shape)
7. destructor s2 (sphere)
8. destructor s2 (shape)

on removing 'virtual' of base class 'shape' (and 'override' tags)
- destructor for sphere3 is called only once, since it's not linked with child class
- because:
  - shape -> sphere
  - shape delete -> calls size_of for size of object 
    - -> gets size of base class, because not virtual 
    - -> only deletes base object 

1. constructor s1 (shape)
2. constructor s1 (sphere)
3. constructor s2 (shape)
4. constructor s2 (sphere)
5. destructor s1 (sphere)
6. destructor s1 (shape)
7. destructor s2 (shape)

## Task 5.9

**Klassenhierarchie**
- baumartige Struktur
- ist Beziehung zwischen Klassen dar (Basisklasse und abgeleitete Klassen)

**Objekthierarchie**
- Relationen (Ordnung, Komposition) der Objekte in einem System (Geschwister, Eltern, Kinder, usw..)

**Klassendiagramm**
- zeigt statische Struktur eines Systems in Diagram Form
- allgemein: Klassennamen, Attribute, Relation zwischen Klassen

**Objektdiagramm**
- stellt alle Objekte eines Systems mit ihren Relationen (Ordnung, Komposition) dar
- mehrere Objekte einer Klasse möglich
- Objektname, Klassennamen, Klassenattribute mit zugewiesenen Werten, Relation zu anderen Objekten (Geschwister, Eltern, Kinder, usw..)

## Task 6.1

```cpp
void raycast()
	for all pixels(x,y)
		image(x,y) = trace( compute_eye_ray(x,y) )
```

→ go through each pixel of image<br />
→ send out ray<br />
→ get pixel array<br />
→ convert to image and display<br />

```cpp
rgbColor trace(ray r)
	for all objects o
		t = compute_intersection(r, o)
		if (t < closest_t)
			closest_t = t
			closest_o= o
		if (closest_o != 0)
			return shade(closest_o, r, closest_t)
		else
			return background_color
```

→ compute intersection for all objects<br />
→ if no object found: return background color<br />
→ if object(s) found: find closest object<br />
→ compute shade on pixel and return color<br />

```cpp
rgbColor shade(object o, ray r, double t)
	point x = r(t)
	// evaluate(Phong) illumination equation
	return color
```

→ send out ray from intersection to point light nodes<br />
→ compute lighting using Phong and ambient and point lights<br />
→ return light-influenced color for pixel<br />
<br />
<br />
<br />
**Missing: reflection**<br />
→ shootout rays from intersection with light reflection angle<br />
→ if ray hits object, return object color →  send new ray (infinitely)<br />
→ if ray reaches max depth, return background color<br />
→ use calculated distance and apply color with a factor to first object
