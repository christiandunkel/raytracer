

# Theoretical Tasks
[Back to main page](../README.md)

This page contains all answers to the theoretical tasks of assignment 1 to 7. Tasks without any theoretical questions are excluded from this page.

## Task 1.4

> In the following example, name types, variables and values. Explain the keyword const in this context. What is type conversion, and why can there be problems? Where do you see problems in the following program code?

![A block of code showing the assignment of values to different variable types.](task_1_4.png)
In the given code example, a bunch of values are assigned to different types of variables.

```cpp
int a = 9; // whole number type
bool b = false; // truth value type 
char c = 'a'; // character type
double d = 1.3; // floating point number
int const five = 5; // unchangeable whole number type 
double e = a/five; // equals 1.0, since integers are divided first, and only parsed to double afterwards 
five = d; // not possible, since five is a constant
```

## Task 1.5

> Explain the terms initialization and assignment in terms of variables and give an example each. What differences are there?

`Initialization` is the first assignment of a value to a variable, for example: 

```cpp
int a = 10;
```

`Assignment` is the general assignment of a value to a variable, which can but doesn't have to be the initialization. For example, both lines in the following code are assignments of values: 

```cpp
int b = 9; 
b = 10;
```

Every initialization is an assignment, but not every assignment is an initialization. The initialization only happens once, when the variable first gets a value assigned.

## Task 1.6

> Explain the term 'declaration', also sometimes referred to as 'forward declaration', and 'definition', as well as give an example each. What differences are there? Give examples for 'declaration' and 'definition' in the context of functions, variables, and classes.

`Declaration` means in C++, that you tell the compiler, the type and size of a given variable or constant. This also applies to class structures, where you declare the type (class/struct) and functions, where you declare the function signature with the type and size of all its parameters.

```cpp
extern int a;
void foo();
int bar(int);
class FooBar;
struct BarFoo;
```

`Definition` makes in addition to the declaration of type and size, also reserves space in the memory of the machine.

```cpp
int a;
int b = 10;
int foo(int a) {return a;}
class FooBar{int a;};
struct BarFoo{int a;};
```

A declaration gives the compiler the information, that a variable or function exists, while the definition then reserves memory on the machine.

## Task 1.7

> What is part of the signature of a function? Determine the scope of all variables in the following example.

A `function signature` consists of a access modifier like *public* or *private*, possibly a *static* keyword, a return type, which may also be *void*, if nothing will be returned by the function, and a name. After that, the parameter variables are listed inside parenthesis with their type and local name each.

![Showing three functions, including a main function, a sum function to add up two doubles, and a square function that multiplies a value with itself.](task_1_7.PNG)
```cpp
int var = 3; // global scope, valid in whole class

double sum (double a, double b) {
  // a and b are only valid locally inside this method
}

int square(int var) {
  // var is only valid locally inside this method
}

int main() {
  for (int i = 0; i != 100; ++i) {
    // i is only valid inside loop
  }
}
```

## Task 1.16

> Write down a definition for each term in the list.

- `C++` is a generic, imperative, object-oriented, procedural, structured, functional programming language, that was originally intended as an extension of the C language.
- `Source code` is the sequence of high-level language instructions processed by a computer.
- `Compiler` translates program code into machine language for the processor.
- `Linker` is a number of multiple object files generated by a compiler combined into a single program. 
- `Object code` is a special intermediate product of compilers, consisting of individual modules from the source code that are translated to machine-readable code, and which can be linked by linkers.
- `Executable file` can be executed as a program by a computer.
- `main()` is the start method of a program written in the C++ language. 
- `#include` includes the content of other files into the source code, which can then be used in the source code.
- `Comments` won't be translated into machine language, and just serve as reminders, descriptions and explanations for the programmers looking at the source code. 
- `Headers`  are files with the file ending *.h* or *.hpp*, which generally declare functions and variables, that can then be defined in the linked *.cpp* file(s).
- `Programs` are series of commands to a computer for it to perform certain operations.
- `Output` is the display of the results of an executed program, generally over a terminal.
- `std::cout` is a method of the standard C++ library to output information into the terminal. 
- `std::cin` is a method of the standard C++ library to receive user input from the terminal for usage in the program.
- `<<` is the standard output operator.
- `>>` is the standard input operator.
- `Functions` are programming constructs helpful for structuring the source code, as they can be called using a method invocation. Their content can thus be executed multiple times in different contexts.
- `Functions signatures` declare a function with their access modifier, possibly a static keyword, a return type, a name and input parameters.
- `Declaration` makes a variable type and name, or function, class or struct known to the compiler.
- `Definition` reserves space in the memory of the machine for a given declaration.
- `Type` declares the kind of content of a variable or parameter.
- `Typ conversion` describes the process of converting a variable of one type into another type, for example:


```cpp
int i = 1;  
double j = i; // j equals 1.0
```

- `Variables` are a characteristic, number or quantity, that can be increased or decreased, changed or exchanged, and can be referenced by name inside the program.
- `Name` is something by which variables, functions, classes, and similar are referenced inside the source code and by which one can access its content.
- `Value` is the content of a variable, which is associated with a variable name, which can be accessed inside the program using this name.
- `Initialization` is the first assignment of a value to a variable.
- `Assignment` is the general assignment of a value to a variable, which can but doesn't have to be the initialization.
- `const` is a keyword that declares a variable as constant, making it so that its content can only be read, but not changed.
- `Scope` is the region inside the source code, where a variable is valid or *visible*, meaning it can be referenced.

## Aufgabe 2.2
*Include guards* ist eine Technik mit welcher das mehrfache Einbinden eines Headers unterbunden wird. Werden die Header, z.B. *Vec2.hpp*, zweimal eingebunden, wird es Compilation Errors geben, da hier z.B. die struct  Vec2 zweifach definiert werden würde.

## Aufgabe 2.7
`struct` Konstrukte haben standardmäßig öffentliche Members und eignen sich als Datenstrukturen.

`class` Konstrukte standardmäßig private Members haben, und diese nach Konvention auch nicht zu public umgeformt, und nur per *get* abgerufen werden sollten! 

*Datentransferobjekte* oder auch *DTO* sind ein Entwurfsmuster, bei dem mehrere Daten / Methoden in einem Objekt gebündelt werden. Dann muss man das Objekt nur einmal aufrufen, um dann die Methoden zur Verfügung zu haben ohne weitere Fernzugriffe.

## Aufgabe 2.9
Nach dem C++ Standard existieren keine *Methoden*, obwohl dieser Begriff dennoch oft auswechselbar mit *Funktionen* verwendet wird.
Man könnte mit einer Methode Funktionen beschreiben, die abhängig von einem Objekt sind, währenddessen Funktionen allgemein auch global und allgemein gültig sein können.
Bei const-Member Methoden wird das Versprechen gegeben, dass das Objekt, auf dem sie aufgerufen werden, nicht verändert wird. Bei Funktionen die unabhängig von Objekten sind, bestimmt const je nach Anwendung über das Versprechen, das ein Rückgabewert oder Parameter nicht verändert werden darf.

## Aufgabe 2.12
Das *Überladen* von Funktionen, auch als *Overloading* bezeichnet, beschreibt das Definieren unterschiedlicher Funktionen mit gleichem Namen, aber unterschiedlichen Eingabeparametern. Hierbei wird beim Aufrufen die Funktion verwendet, die zu den Eingabeparametern passt. 

## Aufgabe 3.1
**Sequentielle Container** sind Container-Klassen, die Daten in einer Sequenz speichern. Hierbei wird entweder über einen numerischen Index, welcher die Stelle eines Wertes in der Sequenz beschreibt, oder durch das Wandern über andere Elemente auf den gesuchten Wert zugegriffen.
*Bsp.: array, vector, dequeue, list, ...*

**Assoziative Container** sind Container-Klassen die in Paaren aus Schlüssel und Wert speichern, wobei der Schlüssel die Position beschreibt, an welcher der Wert im Container gespeichert wird. Somit wird also über den Schlüssel auf den Wert zugegriffen.
*Bsp.: map, set  (value itself is the key), ...*

**Komplexität**
|  | Sequenz | Assoziativ |
|--|--|--|
| Insertion | Constant | O(log n) |
| Removal | Constant | O(log n) |
| Search | Constant | O(log n) |

- `Speichern der Punkte eines Polygons`
Hier bietet sich der *Sequentieller Container* z.B. ein *Array von Vektoren* an, da hier nicht standardmäßig nach Werten sortiert wird, und man die sequentielle Reihenfolge dazu nutzen kann um herauszufinden was der nächste Punkt ist zu dem man zeichnen muss von einem Punkt aus. 

- `Zuordnung von Farbnamen und entsprechenden RGB-Werten`
Hier bietet sich der *Assoziativer  Container* z.B. eine *Map* an, da man den Schlüssel für den Namen und den Wert für das RGB verwenden kann, und keine Duplikate zugelassen sind.

- `FIFO-Warteschlange von Druckaufträgen`
Hier bietet sich der *Sequentieller Container* z.B. eine *Queue* an, da man hier die Warteschlange bzw. Sequenz schön nacheinander abarbeiten kann. Die Reihenfolge muss man sich nicht merken, da sie schon in der Sequenz an sich gespeichert ist.

## Aufgabe 3.3
std::map is useful for this task, because it:
   - only has unique keys with one value mapped to it
   - sorts keys by default
   - searching for keys is very fast (logarithmic time)

## Aufgabe 3.5

**ORIGINAL**

    std :: map <string ,int > matrikelnummern ;
    // Hinzufuegen von vielen Studenten
    matrikelnummern ["Max Mustermann"] = 12345;
    matrikelnummern ["Erika Mustermann"] = 23523;
    // ...
    exmatrikulation (matrikelnummer["Fred Fuchs"]);

**FEHLER**

`std::map<string, int>` --> `std::map<std::string, int>`
`matrikelnummer["Fred Fuchs"]` --> `matrikelnummern["Fred Fuchs"]`

**PROBLEME**

- Keys lassen keine Duplikate zu, sollten also hier die Matrikelnummern sein, da doppelte Namen keine Seltenheit sind
- Übergabe von Matrikelnummer als Integer, `exmatrikulation()` hat möglicherweise keinen Zugriff auf die Map --> Fred Fuchs wird exmatrikuliert, bleibt in der Liste

**METHODEN**

*Einfügen eines Paars*

     a_map[key] = value;
     a_map.insert(std::make_pair(key, value));

*Entfernen von Paar*

    erase(e) // Entfernen per Key oder per Iterator (Element auf das dieser pointet)

    erase(it1,it2) // Entfernen von Elementen des in Range der Iteratoren it1 bis it2 - 1

*Finden eines Keys*

    wordMap.count(key) > 0 // Testet ob Key existiert mittels count()
    
    it = wordMap.find(key);
    it != wordMap.end() // Testet ob Key existiert mittels Iterator und find()

*Allgemeine Methoden*

`std::search` Suche erstes Aufkommen einer Zeichensequenz in der gegebenen Reichweite nach dem Kriterium

`std::find` Suche erstes Aufkommen eines Elementes in der gegebenen Reichweite nach dem Kriterium

`iterator` vs `const_iterator` Normale Iteratoren erlauben das Ändern der gefundenen Elemente, anders als const Iteratoren -> möglicherweise Problem

## Aufgabe 4.8

**DEEP-COPY**: - copy values, objects will be traversed and their values copied as well
**SHALLOW-COPY**: - copy only simple data types, copy references to objects / complex datatypes

**copy constructor is called when**:
- an object is returned by value
- an object of class is passed to a function by value
- an object is constructed based on another object of the same class
- the compiler generates a temporary object

**by default, C++ compiler creates its own default** copy constructor (shallow-copy)

**custom copy-constructor is needed**, if there are pointers or any runtime allocation, also allows for deep copy        

**Why copy-constructor pass by value?** -> copy constructor is a function in its basic form
that is always called when there is an argument pass by value ->
if not using reference in copy constructor -> infinite loop

## Aufgabe 4.14

Move Constructor??
auto l = List<int>{1,2,3,4,5} + List<int>{6,7,8,9};

## Task 5.3

- beim Erstellen des Sphere Objekts
- ruft den Konstruktor der Basisklasse (Shape) zuerst auf, dann den Konstruktor der abgeleiteten Klasse (Sphere)
- wenn der eine Initialisierungsliste existiert, konstruktor der basisklasse wird am Anfang der Liste aufgerufen
- Konstruktor der Basisklasse kann als Punkt in Liste (am Anfang) definiert werden e.g. Shape(), Shape(string name), ..

## Task 5.5

*override*
- stellt sicher, dass eine Funktion virtuell ist
- *falls dies nicht zutrifft: compile error*
- definiert, dass eine Klasse eine virtuelle Funktion seiner Basisklasse überschreibt (ersetzt)

## Task 5.7

**dynamic variable** 
- variable whose address is determined when the program is run

**static variable**
- already known at compilation time, has memory reseved for it at compilation time

*std::shared_ptr*
- smart pointer
- retains shared ownership of an object thrugh pointer
- several smart pointers may own the same object
- object is destroyed, when:
  - last smart pointer owning it is destroyed
  - last smart pointer owning it is assigned another pointer via = o. reset()
- can own object while storing pointer to another
  - for example, can be used to point to an object's member, while still owning the object

*std::make_shared*
- construct T object and wrap it in smart pointer

`std::shared_ptr<Sphere> s1 = std::make_shared<Sphere>(position, 1.2f, red, "sphere0");`
- static pointer -> static pointer
  - in compilation-time known
  - can use all methods of sphere

`std::shared_ptr<Shape> s2 = std::make_shared<Sphere>(position, 1.2f, red, "sphere1");`
- static pointer -> to dynamic object
  - in run-time looks for Sphere object
  - can only run methods of Sphere (but virtual methods overriden by sphere still work)

## Task 5.8

*order of constructor / destructor calls*
1. constructor s1 (shape)
2. constructor s1 (sphere)
3. constructor s2 (shape)
4. constructor s2 (sphere)
5. destructor s1 (sphere)
6. destructor s1 (shape)
7. destructor s2 (sphere)
8. destructor s2 (shape)

on removing 'virtual' of base class 'shape' (and 'override' tags)
- destructor for sphere3 is called only once, since it's not linked with child class
- because:
  - shape -> sphere
  - shape delete -> calls size_of for size of object 
    - -> gets size of base class, because not virtual 
    - -> only deletes base object 

1. constructor s1 (shape)
2. constructor s1 (sphere)
3. constructor s2 (shape)
4. constructor s2 (sphere)
5. destructor s1 (sphere)
6. destructor s1 (shape)
7. destructor s2 (shape)

## Task 5.9

**Klassenhierarchie**
- baumartige Struktur
- ist Beziehung zwischen Klassen dar (Basisklasse und abgeleitete Klassen)

**Objekthierarchie**
- Relationen (Ordnung, Komposition) der Objekte in einem System (Geschwister, Eltern, Kinder, usw..)

**Klassendiagramm**
- zeigt statische Struktur eines Systems in Diagram Form
- allgemein: Klassennamen, Attribute, Relation zwischen Klassen

**Objektdiagramm**
- stellt alle Objekte eines Systems mit ihren Relationen (Ordnung, Komposition) dar
- mehrere Objekte einer Klasse möglich
- Objektname, Klassennamen, Klassenattribute mit zugewiesenen Werten, Relation zu anderen Objekten (Geschwister, Eltern, Kinder, usw..)

## Task 6.1

```cpp
void raycast()
	for all pixels(x,y)
		image(x,y) = trace( compute_eye_ray(x,y) )
```

→ go through each pixel of image<br />
→ send out ray<br />
→ get pixel array<br />
→ convert to image and display<br />

```cpp
rgbColor trace(ray r)
	for all objects o
		t = compute_intersection(r, o)
		if (t < closest_t)
			closest_t = t
			closest_o= o
		if (closest_o != 0)
			return shade(closest_o, r, closest_t)
		else
			return background_color
```

→ compute intersection for all objects<br />
→ if no object found: return background color<br />
→ if object(s) found: find closest object<br />
→ compute shade on pixel and return color<br />

```cpp
rgbColor shade(object o, ray r, double t)
	point x = r(t)
	// evaluate(Phong) illumination equation
	return color
```

→ send out ray from intersection to point light nodes<br />
→ compute lighting using Phong and ambient and point lights<br />
→ return light-influenced color for pixel<br />
<br />
<br />
<br />
**Missing: reflection**<br />
→ shootout rays from intersection with light reflection angle<br />
→ if ray hits object, return object color →  send new ray (infinitely)<br />
→ if ray reaches max depth, return background color<br />
→ use calculated distance and apply color with a factor to first object
